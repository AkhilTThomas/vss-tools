// Simple demo code to print out a signal tree using the
// code generated by vspec2c.py code
//
#include "vss.h"
#include <stdio.h>
#include <stdlib.h>

const char* elem_type_str(vss_element_type_e elem_type)
{
    switch(elem_type) {
    case VSS_ATTRIBUTE: return "attribute";
    case VSS_BRANCH: return "branch";
    case VSS_SENSOR: return "sensor";
    case VSS_ACTUATOR: return "actuator";
    case VSS_RBRANCH: return "rbranch";
    case VSS_ELEMENT: return "element";
    default: return "*unknown*";
    }
}

const char* data_type_str(vss_data_type_e data_type)
{
    switch(data_type) {
    case VSS_INT8: return "INT8";
    case VSS_UINT8: return "UINT8";
    case VSS_INT16: return "INT16";
    case VSS_UINT16: return "uint16";
    case VSS_INT32: return "int32";
    case VSS_UINT32: return "uint32";
    case VSS_DOUBLE: return "double";
    case VSS_FLOAT: return "float";
    case VSS_BOOLEAN: return "boolean";
    case VSS_STRING: return "string";
    case VSS_STREAM: return "stream";
    case VSS_NA: return "na";
    default: return "*unknown*";
    }
}

void dump_signal(vss_signal_t* sig, int indent)
{
    printf("%*sName:        %s\n", indent, "", sig->name);
    printf("%*sDescription: %s\n", indent, "", sig->description);
    printf("%*sType:        %s\n", indent, "", elem_type_str(sig->element_type));
    if (sig->element_type != VSS_BRANCH)
        printf("%*sData Type:   %s\n", indent, "", data_type_str(sig->data_type));

    if (sig->sensor[0] != 0)
        printf("%*ssensor:      %s\n", indent, "", sig->sensor);

    if (sig->actuator[0] != 0)
        printf("%*sactuator:    %s\n", indent, "", sig->actuator);

    printf("%*sUUID: %s\n", indent, "", sig->uuid);

    // Check if we have a define min_val
    if (sig->min_val.i != INT64_MIN) {
        // Print out the right union member
        if (sig->data_type == VSS_FLOAT ||
            sig->data_type == VSS_DOUBLE)
            printf("%*smin_val:     %f\n", indent, "", sig->min_val.d);
        else
            printf("%*smin_val:     %ld\n", indent, "", sig->min_val.i);
    }

    // Check if we have a define max_val
    if (sig->max_val.i != INT64_MIN) {
        // Print out the right union member
        if (sig->data_type == VSS_FLOAT ||
            sig->data_type == VSS_DOUBLE)
            printf("%*smax_val:     %f\n", indent, "", sig->max_val.d);
        else
            printf("%*smax_val:     %ld\n", indent, "", sig->max_val.i);
    }


    if (sig->enum_values[0] != 0) {
        int ind = 0;
        printf("%*senum:        ", indent, "");
        while(sig->enum_values[ind]) {
            printf("%s ", sig->enum_values[ind]);
            ind++;
        }
    }

    // Dump the kids.
    if (sig->element_type == VSS_BRANCH) {
        int ind = 0;
        printf("%*schildren:", indent, "");
        while(sig->children[ind]) {
            dump_signal(sig->children[ind], indent + 2);
            ind++;
        }
        printf("%*s---\n\n", indent, "");
    }

}

int main(int argc, char* argv[])
{
    vss_signal_t* sig = 0;
    dump_signal(&vss_signal[0], 0);
    int res = 0;

    // Grab
    puts("Retrieving Vehicle.VehicleIdentification.VIN by its path");
    if ((res = vss_find_signal_by_path("Vehicle.VehicleIdentification.VIN", &sig))) {
        perror("vss_find_signal_by_path(\"Vehicle.VehicleIdentification.VIN\")");
        exit(255);
    }
    dump_signal(sig, 0);

    puts("\n\nRetrieving Vehicle.Body.Mirrors.Left.Heating.Status by its macro.");
    sig = VSS_Vehicle_Body_Mirrors_Left_Heating_Status();

    if (!sig) {
        puts("Could not resolve a path string to signal for Mirror heating status");
        exit(255);
    }

    dump_signal(sig, 0);

}
